#+BEGIN_EXPORT html
---
layout: post
title: SICP Lecture 1B - Procedures and Processes; The Substitution Model
---

<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
#+END_EXPORT

/This lecture covers mostly \S1.2 of the textbook./

* The substitution model 

To effectively design procedures a model for the processes they generate is required - the
/substitution model/ is a simple model which will suffice to begin investigating this relationship.
The substitution model evaluates a combination as follows:
1) Evaluate the operator to get the procedure
2) Evaluate the operands to get arguments
3) Apply the procedure to the arguments:
   - Copy the body of the procedure, replacing the formal parameters with the values of the supplied
     arguments
   - Evaluate the resulting new body
this process is recursive and continues until primitives which can be evaluated directly are
reached.
As an example evaluating ~(sos 3 4)~ using the substitution model would play out like:

#+CAPTION: Evaluating a combination using the substitution model
#+NAME: src:subst-model-example
#+BEGIN_SRC scheme
  (define (square x)
    (* x x))
  (define (sos x y)
    (+ (square x)
       (square y)))

  (sos 3 4)
  (+ (square 3) (square 4))
  (+ (square 3) (* 4 4))
  (+ (square 3) 16)
  (+ (* 3 3) 16)
  (+ 9 16)
  25
#+END_SRC

** Normal-order evaluation

The example above used /applicative-order/ evaluation, evaluating the operator and operands
immediately before applying the procedure - this is the approach used by =scheme=.
Alternatively /normal-order/ evaluation only evaluates operands when their values are needed, /e.g./
#+CAPTION: Normal-order evaluation example
#+NAME: src:subs-model-example-normal-order
#+BEGIN_SRC scheme
  (sos 3 4)
  (+ (square 3) (square 4))
  (+ (square 3) (* 4 4))
  (+ (* 3 3) (* 4 4))
  (+ (* 3 3) 16)
  (+ 9 16)
  25
#+END_SRC

** Special forms: conditionals

/Special forms/ don't obey the usual evaluation rules, take ~if~ for example
#+BEGIN_SRC scheme
  (if <predicate>
      <consequent>
      <alternative>)
#+END_SRC
under normal evaluation rules both ~<cosequent>~ and ~<alternative>~ would be evaluated in addition to
~<predicate>~, this is undesirable - see problem 1.5 for an example why - instead the ~if~ special form
is evaluated as
1) Evaluate ~<predicate>~
2) IF true, evaluate ~<consequent>~ expression
3) Otherwise, evaluate ~<alternative>~ expression

* Processes from procedures

The idea of modelling how procedures give rise to processes is to enable design of procedures that
yield efficient processes (for some measure of efficiency: speed, memory, ...), examples to
demonstrate this are given below.

** Example: P\eacute{}ano arithmetic

Given a way to increment and decrement a number by one (in scheme the ~1+~ and ~1-~ operators
respectively) addition of two numbers can be defined as
#+BEGIN_SRC scheme
  (define (peano+ x y)
    (if (= x 0)
        y
        (peano+ (1- x) (1+ y))))
#+END_SRC
giving, /e.g./
#+BEGIN_SRC scheme
  (peano+ 3 4)
  (peano+ (1- 3) (1+ 4))
  (peano+ 2 5)
  (peano+ (1- 2) (1+ 5))
  (peano+ 1 6)
  (peano+ (1- 1) (1+ 6))
  (peano+ 0 7)
  7
#+END_SRC
treating the ~1+~ and ~1-~ operators as primitive.

A similar, but very subtly different, implementation of addition is given below
#+BEGIN_SRC scheme
  (define (peano+-2 x y)
    (if (= x 0)
        y
        (1+ (peano+-2 (1- x) y))))
#+END_SRC
as can be seen it is nearly identical to the former definition, however the process it evolves is
significantly different:
#+BEGIN_SRC scheme
  (peano+-2 3 4)
  (1+ (peano+-2 2 4))
  (1+ (1+ (peano+-2 1 4)))
  (1+ (1+ (1+ (peano+-2 0 4))))
  (1+ (1+ (1+ 4)))
  (1+ (1+ 5))
  (1+ 6)
  7
#+END_SRC

Both approaches follow a common principle of reducing a problem to a simpler, base case for which
the answer is known, here $x\rightarrow0$.
Each implementation also involves a number of steps proportional to the input ~x~ performing
$\mathcal{O}\left(x\right)$ work.
The major difference is the work deferred by ~peano+-2~ building up a string of increments to be
performed once the base case is reached, the width of each line is in some sense the amount of stuff
the computer must remember, ~peano+~ is an /iteration/ requiring constant memory $\mathcal{O}\left(1\right)$ whilst
~peano+-2~ has $\mathcal{O}\left(x\right)$ memory requirements and is thus a (linear) /recursion/.[fn:1]
A key difference is that an iteration has /explicit state/ stored in its variables - it can be stopped
and restarted as if nothing happened - whereas recursions store /implicit state/ in the process.

** Example: Fibonacci numbers

A classic example of recursive procedures and processes are the Fibonacci numbers
\begin{equation*}
  Fib\left(n\right) =
  \begin{cases}
    0 & n = 0 \\
    1 & n = 1 \\
    Fib\left(n - 2\right) + Fib\left(n - 1\right) & \mbox{otherwise}
  \end{cases}
\end{equation*}
which translates almost directly into lisp
#+BEGIN_SRC scheme
  (define (fib n)
    (if (< n 2)
        n
        (+ (fib (- n 1)
                (- n 2)))))
#+END_SRC
The process this evolves is /tree recursive/ - as can be seen ~(fib n)~ requires evaluating ~(fib (- n
1))~ and ~(fib (-n 2))~, ~(fib (- n 2))~ requires evaluating ~(fib (- n 1))~ and so on - resulting in an
exponential growth in work (in fact evaluating ~(fib n)~ requires
$\mathcal{O}\left(Fib\left(n\right)\right)$ work) - the memory requirements can be determined by
examining the length of the longest branch, here memory is $\mathcal{O}\left(n\right)$.

*** Exercise: An iterative Fibonacci process

An iterative Fibonacci process would evaluate ~(fib n)~ in $\mathcal{O}\left(1\right)$ space.

For the general case the new value can be computed from the two previous values, so an iterative
process requires storing these two pieces of information in addition to the counter to determine
when to stop, my implementation is given in listing\nbsp[[src:fib-iter]].
#+NAME: src:fib-iter
#+BEGIN_SRC scheme
  (define (fib n)
    (define (fib-iter ctr f1 f2)
      (cond ((= ctr n)
             (+ f1 f2))
            (else
             (fib-iter (1+ ctr) (+ f1 f2) f1))))
    (cond ((= n 0)
           0)
          ((= n 1)
           1)
          (else
           (fib-iter 1 1 0))))
#+END_SRC

The textbook implementation is more elegant, handling the base cases automatically
#+BEGIN_SRC scheme
  (define (fib n)
    (define (fib-iter ctr f1 f2)
      (if (= ctr 0)
          f2
          (fib-iter (1- ctr) (+ f1 f2) f1)))
    (fib-iter n 1 0))
#+END_SRC

Whilst the tree-recursive process is computationally inefficient they are useful due to the ease of
implementation, the iterative process required effort up front to develop.[fn:2]

* Problem set 1

* Footnotes

[fn:2] Could a /sufficiently smart/ compiler transform an easy to specify tree-recursive procedure
into a more efficient one producing the same result?

[fn:1] Note that both procedure definitions are recursive yet the processes they yield are an
iteration and a recursion, respectively.
