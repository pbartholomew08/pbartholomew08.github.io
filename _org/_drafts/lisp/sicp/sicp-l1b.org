#+BEGIN_EXPORT html
---
layout: post
title: SICP Lecture 1B - Procedures and Processes; The Substitution Model
---

<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
#+END_EXPORT

/This lecture covers mostly \S1.2 of the textbook./

* The substitution model 

To effectively design procedures a model for the processes they generate is required - the
/substitution model/ is a simple model which will suffice to begin investigating this relationship.
The substitution model evaluates a combination as follows:
1) Evaluate the operator to get the procedure
2) Evaluate the operands to get arguments
3) Apply the procedure to the arguments:
   - Copy the body of the procedure, replacing the formal parameters with the values of the supplied
     arguments
   - Evaluate the resulting new body
this process is recursive and continues until primitives which can be evaluated directly are
reached.
As an example evaluating ~(sum-of-squares 3 4)~ using the substitution model would play out like:

#+CAPTION: Evaluating a combination using the substitution model
#+NAME: src:subst-model-example
#+BEGIN_SRC scheme
  (sum-of-squares 3 4)
  (+ (square 3) (square 4))
  (+ (square 3) (* 4 4))
  (+ (square 3) 16)
  (+ (* 3 3) 16)
  (+ 9 16)
  25
#+END_SRC

** Normal-order evaluation

The example above used /applicative-order/ evaluation, evaluating the operator and operands
immediately before applying the procedure - this is the approach used by =scheme=.
Alternatively /normal-order/ evaluation only evaluates operands when their values are needed, /e.g./
#+CAPTION: Normal-order evaluation example
#+NAME: src:subs-model-example-normal-order
#+BEGIN_SRC scheme
  (sum-of-squares 3 4)
  (+ (square 3) (square 4))
  (+ (square 3) (* 4 4))
  (+ (* 3 3) (* 4 4))
  (+ (* 3 3) 16)
  (+ 9 16)
  25
#+END_SRC

** Special forms: conditionals

/Special forms/ don't obey the usual evaluation rules, take ~if~ for example
#+BEGIN_SRC scheme
  (if <predicate>
      <consequent>
      <alternative>)
#+END_SRC
under normal evaluation rules both ~<cosequent>~ and ~<alternative>~ would be evaluated in addition to
~<predicate>~, this is undesirable - see problem 1.5 for an example why - instead the ~if~ special form
is evaluated as
1) Evaluate ~<predicate>~
2) IF true, evaluate ~<consequent>~ expression
3) Otherwise, evaluate ~<alternative>~ expression

* Processes from procedures

The idea of modelling how procedures give rise to processes is to enable design of procedures that
yield efficient processes (for some measure of efficiency: speed, memory, ...), examples to
demonstrate this are given below.

** Example: P\eacute{}ano arithmetic

Given a way to increment and decrement a number by one (in scheme the ~1+~ and ~1-~ operators
respectively) addition of two numbers can be defined as in listing\nbsp[[src:peano+.scm]], yielding the
process shown in listing\nbsp[[src:peano+-example.scm]], treating the ~1+~ and ~1-~ operators as primitive.

#+CAPTION: Implementing addition in P\eacute{}ano arithmetic
#+NAME: src:peano+.scm
#+BEGIN_SRC scheme
  (define (peano+ x y)
    (if (= x 0)
        y
        (peano+ (1- x) (1+ y))))
#+END_SRC

#+CAPTION: Evaluating $3 + 4$ with P\eacute{}ano arithmetic
#+NAME: src:peano+-example.scm
#+BEGIN_SRC scheme
  (peano+ 3 4)
  (peano+ (1- 3) (1+ 4))
  (peano+ 2 5)
  (peano+ (1- 2) (1+ 5))
  (peano+ 1 6)
  (peano+ (1- 1) (1+ 6))
  (peano+ 0 7)
  7
#+END_SRC

A similar, but very subtly different, implementation of addition is given in
listing\nbsp[[src:peano+-2.scm]].
As can be seen ~peano+-2~ is nearly identical to the former definition, however the process it evolves
in listing\nbsp[[src:peano+-2-example.scm]] is significantly different.

#+CAPTION: Alternative implemenation of addition in P\eacute{}ano arithmetic
#+NAME: src:peano+-2.scm
#+BEGIN_SRC scheme
  (define (peano+-2 x y)
    (if (= x 0)
        y
        (1+ (peano+-2 (1- x) y))))
#+END_SRC

#+CAPTION: Evaluating $3 + 4$ with alternative P\eacute{}ano arithmetic implementaion
#+NAME: src:peano+-2-example.scm
#+BEGIN_SRC scheme
  (peano+-2 3 4)
  (1+ (peano+-2 2 4))
  (1+ (1+ (peano+-2 1 4)))
  (1+ (1+ (1+ (peano+-2 0 4))))
  (1+ (1+ (1+ 4)))
  (1+ (1+ 5))
  (1+ 6)
  7
#+END_SRC

Both approaches follow a common principle of reducing a problem to a simpler, base case for which
the answer is known, here $x\rightarrow0$.
Each implementation also involves a number of steps proportional to the input ~x~ performing
$\mathcal{O}\left(x\right)$ work.
The major difference is the work deferred by ~peano+-2~ building up a series of increments to be
performed once the base case is reached, the width of each line is in some sense the amount of stuff
the computer must remember, ~peano+~ is an /iteration/ requiring constant memory
$\mathcal{O}\left(1\right)$ whilst ~peano+-2~ has $\mathcal{O}\left(x\right)$ memory requirements and
is thus a (linear) /recursion/.[fn:1]
A key difference is that an iteration has /explicit state/ stored in its variables - it can be stopped
and restarted as if nothing happened - whereas recursions store /implicit state/ in the process.

** Example: Fibonacci numbers

A classic example of recursive procedures and processes are the Fibonacci numbers
\begin{equation*}
  Fib\left(n\right) =
  \begin{cases}
    0 & n = 0 \\
    1 & n = 1 \\
    Fib\left(n - 2\right) + Fib\left(n - 1\right) & \mbox{otherwise}
  \end{cases}
\end{equation*}
listing\nbsp[[src:fib.scm]] translates this almost directly into lisp.
The process this evolves is /tree recursive/ - as can be seen ~(fib n)~ requires evaluating ~(fib (- n
1))~ and ~(fib (-n 2))~, ~(fib (- n 2))~ requires evaluating ~(fib (- n 1))~ and so on - resulting in an
exponential growth in work (in fact evaluating ~(fib n)~ requires
$\mathcal{O}\left(Fib\left(n\right)\right)$ work) - the memory requirements can be determined by
examining the length of the longest branch, here memory is $\mathcal{O}\left(n\right)$.

#+CAPTION: Recursive implementation of $Fib\left(n\right)$
#+NAME: src:fib.scm
#+BEGIN_SRC scheme
  (define (fib n)
    (if (< n 2)
        n
        (+ (fib (- n 1)
                (- n 2)))))
#+END_SRC

*** Exercise: An iterative Fibonacci process

An iterative Fibonacci process would evaluate ~(fib n)~ in $\mathcal{O}\left(1\right)$ space.

For the general case the new value can be computed from the two previous values, so an iterative
process requires storing these two pieces of information in addition to the counter to determine
when to stop, my implementation is given in listing\nbsp[[src:fib-iter.scm]].

#+CAPTION: Iterative implementation of $Fib\left(n\right)$
#+NAME: src:fib-iter.scm
#+BEGIN_SRC scheme
  (define (fib n)
    (define (fib-iter ctr f1 f2)
      (cond ((= ctr n)
             (+ f1 f2))
            (else
             (fib-iter (1+ ctr) (+ f1 f2) f1))))
    (cond ((= n 0)
           0)
          ((= n 1)
           1)
          (else
           (fib-iter 1 1 0))))
#+END_SRC

The textbook implementation in listing\nbsp[[src:fib-iter-textbook.scm]] is more elegant, handling the base
cases automatically.

#+CAPTION: Textbook iterative implementation of $Fib\left(n\right)$
#+NAME: src:fib-iter-textbook.scm
#+BEGIN_SRC scheme
  (define (fib n)
    (define (fib-iter ctr f1 f2)
      (if (= ctr 0)
          f2
          (fib-iter (1- ctr) (+ f1 f2) f1)))
    (fib-iter n 1 0))
#+END_SRC

Whilst the tree-recursive process is computationally inefficient they are useful due to the ease of
implementation, the iterative process required effort up front to develop.[fn:2]

** Designing recursive algorithms 

The above examples are all recursively-defined algorithms, giving rise to either recursive or
iterative processes, their designs all follow a similar pattern
1) /Wishful thinking/ - assume that a method exists for solving a smaller/simpler version of the
   problem.
2) /Decomposing the problem/ - take the problem and split it into a combination of simple operations
   and the solution to the smaller problem. This requires some ingenuity.
3) /Identifying the ``smallest'' problem/ - this problem is either non-decomposable or sufficiently
   small that is solved directly.
This results in a program design that tests the input, applying either the /recursive case/ or the
/base case/ when the smallest input is reached.

*** Example: Factorial

Another well known recursive algorithm is calculating the factorial
\begin{equation}
  n! =
  \begin{cases}
    n \left( n - 1 \right)! & n > 1 \\
    1 & \mbox{otherwise}
  \end{cases}
\end{equation}
as can be seen it consists of a test resulting in either the application of a simple procedure
(multiplication) to a smaller version of the problem $\left( n - 1 \right)!$, or a base case which
immediately returns its solution /i.e./ $1$.

Defining a recursive procedure follows relatively trivially
#+BEGIN_SRC scheme
  (define (fact n)
    (if (> n 1)
        (* n (fact (- n 1)))
        1))
#+END_SRC

*** Formal proofs

* Footnotes

[fn:2] Could a /sufficiently smart/ compiler transform an easy to specify tree-recursive procedure
into a more efficient one producing the same result?

[fn:1] Note that both procedure definitions are recursive yet the processes they yield are an
iteration and a recursion, respectively.
