#+BEGIN_EXPORT html
---
layout: post
title: SICP Lecture 1A - Introduction
---

<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
#+END_EXPORT

/Modified on 2020-04-19 to add notes on scoping including block structuring code./
/Modified on 2020-07-27 to tidy the text./

#+BEGIN_QUOTE
Computer science is a terrible name for this business - first of all it's not science, it might be
engineering or it might be art ...
It's also not really very much about computers. -- Hal Abelson
#+END_QUOTE

* Introduction

After several abortive attempts what better time to work through SICP than the =COVID-19= lockdown!
These are my notes based on the MIT-OCW lecture series videos in combination with the MIT-OCW
lecture notes from 2007 and the /Structure and Interpretation of Computer Programs 2^{nd} ed./ book
itself.
This first video lecture covers roughly \S1.1.1-1.1.4 and \S1.1.6-1.1.7 of SICP, and is mostly
contained in lecture notes 1 and 2.

"Computer science" could be better understood as the /study of processes/ that is "how to",
more formally /imperative/, knowledge.
This contrasts with "what is", or /declarative/, knowledge.
As an example, the statement
\begin{equation*}
  \begin{split}
    \sqrt{x}\ \mbox{is the } y\ \mbox{such that}& \\
    y^2 &= x,\ y \geq 0
  \end{split}
\end{equation*}
defines what the square root is, whereas Heron of Alexandria's algorithm
\begin{equation*}
  \begin{split}
    \mbox{Given an initial guess } y_0:&\\
    y_{n+1} &= \frac{y_n + x/y_n}{2}\ \mbox{while } \left|y^2_n - x\right| > \varepsilon
  \end{split}
\end{equation*}
is a /procedure/ for how to compute (or estimate) the square root.
/Evaluating/ the procedure results in a /process/ that evolves the input data to return a value.

Ultimately, we want to be able to perform complex tasks, this necessarily results in complex
processes, the aim of studying processes is /controlling complexity/.
SICP studies three approaches to managing complexity:
1) Procedure and data abstraction
   - hiding complexity in "black boxes"
2) Conventional interfaces and programming paradigms
   - standard ways of connecting simpler pieces
     - manifest typing
     - streams
     - object oriented programming
3) Metalinguistic abstraction
   - tayloring a language to fit the problem domain

Around this point in the lecture Hal Abelson points out that the complexity stems only from the
problem itself: a physical implementation of a system using /real/ components must also tackle
problems arising from physical constraints such as noise, tolerance, /etc/.; in contrast processes in
computer science are built from ideal, /not/ approximated, components and thus are really only limited
by imagination.

* Black boxes
<<sec:black-boxes>>

The focus of this lecture is introducing black boxes as a means of abstraction.

Black boxes allow us to take the details of something, /e.g./ finding the square root of $x$, and
abstract it away as a primitive object, /e.g./ a procedure ~sqrt~ which when supplied with $x$ returns
$y = \sqrt{x}$.
Knowing what ~sqrt~ does allows a user to use ~sqrt~ whenever a square root is needed without
necessarily knowing /how/ to compute $\sqrt{x}$, allowing them to concentrate on the task at hand and
combine it with other procedures to build yet more complex procedures.

A black box can also be used to express generality, for instance the method for finding a square
root described above is an example of finding the fixed point of a function
\begin{equation*}
  f \left( y \right) = y
\end{equation*}
so ~sqrt~ could be expressed as finding the fixed point of the function
\begin{equation*}
  f \left( y_{n+1} \right) = \frac{y_n + x / y_n}{2}
\end{equation*}
this would fundamentally be the same as Heron's algorithm, although the convergence test would be
looking for small changes in the result /i.e./ $\Delta{}y\rightarrow0$.

In order to build these black boxes, a language must provide:
- Primitive objects
  - what can we accept as true?
- Means of combination
  - how can we build compound elements from simpler ones?
- Means of abstraction
  - how can we express these compound elements as if they were primitive ones?

* A brief introduction to LISP
<<sec:lisp-intro>>

In SICP the scheme dialect of LISP is used (I will be using the guile implementation of scheme),
this brief introduction covers most of the basics of LISP/scheme.

** LISP primitives
<<sec:lisp-primitives>>

The simplest elements of LISP are the /self-evaluating/ expressions, symbols which evaluate as
themselves, this includes ~numbers~, ~strings~ and ~Booleans~, /e.g./ ~3~, ~"hello world!"~ and ~#t~ and ~#f~.
These primitive objects can be manipulated using built-in procedures such as ~+~, ~-~, ~*~, ~/~,
~string-length~, ~string=?~, ~and~ and ~or~.
Interestingly while these operations are generally treated as /primitive/, they are in fact names or
/symbols/ for procedures /e.g./ ~+~ is the name for the procedure ~sum~.

** LISP combinations
<<sec:lisp-combinations>>

LISP symbols are combined using parentheses to form a /combination/ that is evaluated following
prefix-notation rules, /e.g./ ~(+ 3 17.4 5)~ is a combination comprising an /operator/ whose value is a
procedure followed by a list of operands.
/Evaluating/ a combination returns a /value/ by applying the operator procedure to the operand values
/i.e./ the operands are evaluated before evaluating the combination, allowing for /nested/ combinations
such as
#+BEGIN_SRC scheme
  (+ (* 2 3)
     4)
#+END_SRC
which is evaluated as ~(+ 6 4)~ returning ~10~ as its value.

** Abstracting in scheme
<<sec:scheme-abstractions>>

It would not be very useful to have to write out procedures in full whenever they are required or
have mysterious numbers floating around, to resolve this abstraction is used to generate a /name/
whose /value/ is the object, for instance the code in listing\nbsp[[src:example-definitions.scm]] creates two
symbols ~pi~ and ~a~ whose values are ~3.14~ and the procedure ~(* 5 5)~, respectively.

#+CAPTION: Example of defining new symbols
#+NAME: src:example-definitions.scm
#+BEGIN_SRC scheme
  (define pi 3.14)
  (define a (* 5 5))
#+END_SRC

The expressions in listing\nbsp[[src:example-definitions.scm]] are /special forms/, in that they don't follow
the normal rules of evaluation.
Consider that if they did the interpreter would first have to evaluate ~pi~ before applying the ~define~
procedure to the values of ~pi~ and ~3.14~ when the intention of the expression is to associate ~3.14~
with the symbol ~pi~ in the current /environment/ (here the /global/ environment).
Following the definition, evaluating ~pi~ in this environment will return the value ~3.14~.

** Evaluating combinations
<<sec:eval-combinations>>

As mentioned above in \S[[sec:lisp-combinations]] a combination is evaluated in a two step procedure:
1) First, evaluate sub-expressions in the combination
2) Apply the procedure that is the value of the leftmost sub-expression (the operator) to the
   arguments obtained as the values of the remaining sub-expressions (the operands).

As step 1 shows, the evaluation process is /recursive/ in that it calls itself on the sub-expressions
of a combination.
This recursive definition allows evaluation of deeply nested combinations to be expressed very
clearly and succinctly.
A useful way to visualise how this evaluation process computes a value is by /tree accumulation/,
given a combination to evaluate
#+BEGIN_SRC scheme
  (* (+ 2 (* 4 6))
     (+ 3 5 7))
#+END_SRC
the process can be viewed as a tree where nodes represent evaluations and values are passed up the
branches.
Starting from the root node we evaluate it by passing in the operator and operands from its
branches, the nodes at the end of these branches are evaluated and so on until a terminal node with
a primitive procedure or value is reached, the values then percolate back up the tree to return a
value at the root node.

** Conditional expressions and predicates

In general procedures must perform tests, for example the absolute value of $x$ may be defined as
\begin{equation*}
  \left| x \right| =
  \begin{cases}
    x & x > 0 \\
    -x & x < 0 \\
    0 & \mbox{otherwise}
  \end{cases}
\end{equation*}
in LISP such a case analysis is performed by the ~cond~ expression, listing\nbsp[[src:abs.scm]] shows an
example implementation of $\left| x \right|$ which follows from the mathematical definition.

#+CAPTION: Example implementation of $\left| x \right|$
#+NAME: src:abs.scm
#+BEGIN_SRC scheme
  (define (abs x)
    (cond ((> x 0) x)
          ((< x 0) (- x))
          (else 0)))
#+END_SRC

The ~cond~ expression consists of a series of /clauses/ made up of a predicate and a /consequent
expression/.
Each clause's predicate is evaluated in turn until one returns /true/ when the ~cond~ expression returns
the value of the corresponding consequent expression, the ~else~ keyword handles the default case.

Whilst ~cond~ handles an arbitrary number of clauses, the ~if~ expression handles the /if-then-else/ case
where the truth of a single predicate is tested returning either the /consequent/ or the /alternate/
expression, an alternate definition of ~abs~ is given in listing\nbsp[[src:abs-if.scm]].
Either one may be implemented in terms of the other, generally a =scheme= implementation would pick one
and then implement the other.

#+CAPTION: Implementation of $\left| x \right|$ using ~if~
#+NAME: src:abs-if.scm
#+BEGIN_SRC scheme
  (define (abs x)
    (if (< x 0)
        (- x)
        x))
#+END_SRC

** Abstracting procedures
<<sec:abstract-proc>>

As shown in \S[[sec:scheme-abstractions]] the special form ~define~ links a value to a name which may be a
primitive expression as in the case of ~pi~ or a procedure as for ~a~.
In the example ~a~'s value is the procedure for squaring ~5~, this is very specific and it is likely to
be more useful to create a general procedure, in scheme this is achieved by the ~lambda~ special form.
A procedure to compute the square of an arbitrary number could be created as follows
#+BEGIN_SRC scheme
  (lambda (x)
    (* x x))
#+END_SRC
where the first operand is the list of /formal parameters/ and the second is the /body/ of procedure,
evaluating the ~lambda~ expression returns a procedure object which is some kind of machine
representation of a procedure.

Following the idea that ~define~ gives a value to a name we can combine these forms to create a named
procedure as follows
#+BEGIN_SRC scheme
  (define square (lambda (x)
                   (* x x)))
#+END_SRC
which will produce an object named ~square~ whose value is the procedure to square a number.
This is so useful and common an action that scheme provides /syntactic sugar/ for naming a procedure,
demonstrated in listing\nbsp[[src:square.scm]] which is simply a shorthand for the previous definition.

#+CAPTION: Defining the ~square~ procedure
#+NAME: src:square.scm
#+BEGIN_SRC scheme
  (define (square x)
    (* x x))
#+END_SRC

Either way the resulting named procedure is called as ~(square 4)~ for example which should return ~16~;
for the user ~square~ appears as a new primitive, indistinguishable from those built-in to the scheme
implementation which they could then use to build further procedures such as computing the sum of
squares shown in listing\nbsp[[src:sos.scm]].
Clearly this is better than simply writing out the full algebraic expression as in
listing\nbsp[[src:sos2.scm]] as in the former we have captured the process of squaring a number in the
~square~ procedure, introducing modularity allowing for reuse of ~square~ elsewhere and increasing
readability by suppressing detail through abstraction.

#+CAPTION: Defining the ~sum-of-squares~ procedure
#+NAME: src:sos.scm
#+BEGIN_SRC scheme
  (define (sum-of-squares x y)
    (+ (square x)
       (square y)))
#+END_SRC

#+CAPTION: Defining the ~sum-of-squares~ procedure without abstractions
#+NAME: src:sos2.scm
#+BEGIN_SRC scheme
  (define (sum-of-squares x y)
    (+ (* x x)
       (* y y)))
#+END_SRC

The basic steps of procedural abstraction are
1) Identify steps or "modules" in a process
2) Capture modules in a procedural abstraction
3) Create a procedure to control the interaction between modules
this idea can be applied recursively to each module, simplifying their implementation too.

*** Local names and scope

In order that a procedure's definition and a user's application do not collide, it should not matter
what the names of the formal parameters are, ~(define (sum-of-squares a b))~ should be equivalent to
the above definitions - the parameter names are /local/ to the procedure definition.
This /binding/ of the variable names exists only in the /scope/ of the procedure definition.
/Free variables/, that is those not bound by the procedure definition come from the encompassing
scope.

* Example: Computing square roots

As pointed out in \S[[sec:black-boxes]] Heron of Alexandria's algorithm for computing square roots can be
expressed as finding the fixed point of a function, it is in fact an application of Newton's method
\begin{equation*}
  \begin{split}
    f \left( y_{n+1} \right) &= f \left( y_n \right) + \left. \frac{\partial f}{\partial y}
    \right|_n \Delta y = 0 \\
    \Rightarrow y_{n+1} &= y_n - \left. \frac{\partial f}{\partial y} \right|^{-1}_n f \left( y_n
    \right)
  \end{split}
\end{equation*}
to the function $f\left( y \right) = y^2 - x$.

Applying the process of procedural abstraction outlined above, Newton's method has three major
components:
1) testing whether a guess is good enough
2) if not yet good enough, compute an improved guess and
3) organise testing and updating the guess.

A simple test of whether the guess is good enough is to square it and compare with ~x~, this is
implemented in listing\nbsp[[src:good-enough]].
An improved guess is computed by subtracting the inverse gradient times the current function
evaluation from the current guess, implemented in listing\nbsp[[src:improve-guess]].

#+CAPTION: Testing whether the guess sufficiently approximates $\sqrt{x}$
#+NAME: src:good-enough
#+BEGIN_SRC scheme
  (define (good-enough? guess x)
    (< (abs (func guess x))
       0.001))
#+END_SRC

#+CAPTION: Computing an improved guess to $\sqrt{x}$ given the current guess
#+NAME: src:improve-guess
#+BEGIN_SRC scheme
  (define (grad guess)
    (* 2 guess))
  (define (improve-guess guess x)
    (- guess (/ (func guess x)
                (grad guess))))
#+END_SRC

The process of repeatedly testing and if necessary improving the guess is implemented by the
~sqrt-iter~ procedure which uses the ~if~ special form to determine which action to take based on the
current guess, recursively calling itself with an improved guess if not sufficiently close to the
solution.
Finally the ~sqrt~ function pulls this all together, using ~1.0~ as an initial guess[fn:1].
Note that in the above the function evaluation has been abstracted as the ~func~ procedure also
defined here.

#+CAPTION: Defining the ~sqrt~ procedure
#+NAME: src:sqrt
#+BEGIN_SRC scheme :noweb strip-export :padline no
  <<src:square>>
  (define (func guess x)
    (- (square guess) x))
  <<src:good-enough>>
  <<src:improve-guess>>
  (define (sqrt-iter guess x)
    (if (good-enough? guess x)
        guess
        (sqrt-iter (improve-guess guess x) x)))

  (define (sqrt x)
    (sqrt-iter 1.0 x))
#+END_SRC

#+RESULTS: src:sqrt
: #<unspecified>

Applying ~sqrt~ to some numbers whose square root is known yields
#+BEGIN_SRC scheme :noweb strip-export :exports both
  <<src:sqrt>>
  (sqrt 4)
#+END_SRC
and
#+BEGIN_SRC scheme :noweb strip-export :exports both
  <<src:sqrt>>
  (sqrt 2)
#+END_SRC
which should be close to expected values (note that ~good-enough?~ is relatively crude).

** Improved Implementation of ~sqrt~

The above implementation of ~sqrt~ is functional, however it introduces several procedures whose
names imply general processes - ~good-enough?~, ~grad~, ~improve-guess~ - yet whose definitions are
entirely specific to ~sqrt~.
The idea of local names and scope applies also to procedure definitions, an alternative
implementation of ~sqrt~ exploiting this is given in listing\nbsp[[src:sqrt-block-struct]].
This approach of using local definitions to isolate procedures from the outside environment is
called /block structuring/; note also that the internally defined procedures leave ~x~ as a free
variable, capturing its value from the enclosing scope of ~sqrt-block-struct~ via /lexical scoping/.

#+CAPTION: A block structured implemenation of ~sqrt~.
#+NAME: src:sqrt-block-struct
#+BEGIN_SRC scheme :noweb strip-export
  <<src::square>>
  (define (sqrt-block-struct x)
    (define (f guess)
      (- (square guess) x))
    (define (grad guess)
      (* 2 guess))
    (define (improve-guess guess)
      (- guess (/ (f guess)
                  (grad guess))))
    (define (good-enough? guess)
      (< (abs (f guess))
         0.001))
    (define (sqrt-iter guess)
      (if (good-enough? guess)
          guess
          (sqrt-iter (improve-guess guess))))
    (sqrt-iter 1.0))
#+END_SRC

* Footnotes

[fn:1] It can be shown that using ~1.0~ as an initial guess will converge to the solution.

* Code dump                                                        :noexport:

#+BEGIN_SRC scheme :noweb tangle :tangle ../../../../src/lisp/sicp/sicp-1a.scm
  <<src:square.scm>>
  <<src:sos.scm>>
  <<src:sqrt-block-struct>>
#+END_SRC
