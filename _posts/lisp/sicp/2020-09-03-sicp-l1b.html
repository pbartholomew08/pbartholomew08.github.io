---
layout: post
title: SICP Lecture 1B - Procedures and Processes; The Substitution Model
---

<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

<p>
<i>This lecture covers mostly &sect;1.2 of the textbook.</i>
</p>

<div id="outline-container-org6bd460f" class="outline-2">
<h2 id="org6bd460f"><span class="section-number-2">1</span> The substitution model</h2>
<div class="outline-text-2" id="text-1">
<p>
To effectively design procedures a model for the processes they generate is required - the
<i>substitution model</i> is a simple model which will suffice to begin investigating this relationship.
The substitution model evaluates a combination as follows:
</p>
<ol class="org-ol">
<li>Evaluate the operator to get the procedure</li>
<li>Evaluate the operands to get arguments</li>
<li>Apply the procedure to the arguments:
<ul class="org-ul">
<li>Copy the body of the procedure, replacing the formal parameters with the values of the supplied
arguments</li>
<li>Evaluate the resulting new body</li>
</ul></li>
</ol>
<p>
this process is recursive and continues until primitives which can be evaluated directly are
reached.
As an example evaluating <code>(sum-of-squares 3 4)</code> using the substitution model would play out as in
listing&nbsp;<a href="#org6813d15">1</a>, note: the order of operand evaluation is arbitrary and is <i>not
defined by the scheme standard</i>.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>Evaluating a combination using the substitution model</label><pre class="src src-scheme" id="org6813d15"><span style="color: #4f97d7;">(</span>sum-of-squares 3 4<span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">(</span>+ <span style="color: #bc6ec5;">(</span>square 3<span style="color: #bc6ec5;">)</span> <span style="color: #bc6ec5;">(</span>square 4<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">(</span>+ <span style="color: #bc6ec5;">(</span>square 3<span style="color: #bc6ec5;">)</span> <span style="color: #bc6ec5;">(</span>* 4 4<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">(</span>+ <span style="color: #bc6ec5;">(</span>square 3<span style="color: #bc6ec5;">)</span> 16<span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">(</span>+ <span style="color: #bc6ec5;">(</span>* 3 3<span style="color: #bc6ec5;">)</span> 16<span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">(</span>+ 9 16<span style="color: #4f97d7;">)</span>
25
</pre>
</div>
</div>

<div id="outline-container-org077177e" class="outline-3">
<h3 id="org077177e"><span class="section-number-3">1.1</span> Normal-order evaluation</h3>
<div class="outline-text-3" id="text-1-1">
<p>
The example in listing&nbsp;<a href="#org6813d15">1</a> used <i>applicative-order</i> evaluation, evaluating the
operator and operands immediately before applying the procedure - this is the approach used by
<code>scheme</code>.
Alternatively <i>normal-order</i> evaluation only evaluates operands when their values are needed, as in
listing&nbsp;<a href="#org88130c3">2</a>. 
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 2: </span>Normal-order evaluation example</label><pre class="src src-scheme" id="org88130c3"><span style="color: #4f97d7;">(</span>sum-of-squares 3 4<span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">(</span>+ <span style="color: #bc6ec5;">(</span>square 3<span style="color: #bc6ec5;">)</span> <span style="color: #bc6ec5;">(</span>square 4<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">(</span>+ <span style="color: #bc6ec5;">(</span>square 3<span style="color: #bc6ec5;">)</span> <span style="color: #bc6ec5;">(</span>* 4 4<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">(</span>+ <span style="color: #bc6ec5;">(</span>* 3 3<span style="color: #bc6ec5;">)</span> <span style="color: #bc6ec5;">(</span>* 4 4<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">(</span>+ <span style="color: #bc6ec5;">(</span>* 3 3<span style="color: #bc6ec5;">)</span> 16<span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">(</span>+ 9 16<span style="color: #4f97d7;">)</span>
25
</pre>
</div>

<p>
Both normal- and applicative-order evaluation yield the same results <i>when procedure application can
be modelled by the substitution model</i>, however as there are efficiency benefits to the
applicative-order application this is the one used by the <code>scheme</code> interpreter.
</p>
</div>
</div>

<div id="outline-container-org38f1ab8" class="outline-3">
<h3 id="org38f1ab8"><span class="section-number-3">1.2</span> Special forms: conditionals</h3>
<div class="outline-text-3" id="text-1-2">
<p>
<i>Special forms</i> don&rsquo;t obey the usual evaluation rules, take <code>if</code> for example
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #ce537a; font-weight: bold;">&lt;predicate&gt;</span>
    <span style="color: #ce537a; font-weight: bold;">&lt;consequent&gt;</span>
    <span style="color: #ce537a; font-weight: bold;">&lt;alternative&gt;</span><span style="color: #4f97d7;">)</span>
</pre>
</div>
<p>
under the regular evaluation rules both <code>&lt;consequent&gt;</code> and <code>&lt;alternative&gt;</code> would be evaluated in
addition to <code>&lt;predicate&gt;</code>, this is undesirable - see problem 1.5 for an example why - instead the <code>if</code>
special form is evaluated as:
</p>
<ol class="org-ol">
<li>Evaluate <code>&lt;predicate&gt;</code></li>
<li>IF true, evaluate <code>&lt;consequent&gt;</code> expression</li>
<li>Otherwise, evaluate <code>&lt;alternative&gt;</code> expression</li>
</ol>

<p>
The related <code>cond</code> is similarly a special form with its own rules of evaluation.
</p>
</div>
</div>
</div>

<div id="outline-container-org333bbd3" class="outline-2">
<h2 id="org333bbd3"><span class="section-number-2">2</span> Processes from procedures</h2>
<div class="outline-text-2" id="text-2">
<p>
The idea of modelling how procedures give rise to processes is to enable design of procedures that
yield efficient processes (for some measure of efficiency: speed, memory, &#x2026;), examples to
demonstrate this are given below.
</p>
</div>

<div id="outline-container-org0e4f83c" class="outline-3">
<h3 id="org0e4f83c"><span class="section-number-3">2.1</span> Example: P&eacute;ano arithmetic</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Given a way to increment and decrement a number by one (in scheme the <code>1+</code> and <code>1-</code> operators
respectively) addition of two numbers can be defined as in listing&nbsp;<a href="#org77303f9">3</a>, yielding the
process shown in listing&nbsp;<a href="#org42db46c">4</a>. 
Note that here the <code>1+</code> and <code>1-</code> procedures are <i>below</i> the level of abstraction considered and are
treated as primitive.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 3: </span>Implementing addition in P&eacute;ano arithmetic</label><pre class="src src-scheme" id="org77303f9"><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">define</span> <span style="color: #bc6ec5;">(</span><span style="color: #bc6ec5; font-weight: bold;">peano+</span> x y<span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span><span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #2d9574;">(</span>= x 0<span style="color: #2d9574;">)</span>
      y
      <span style="color: #2d9574;">(</span>peano+ <span style="color: #67b11d;">(</span>1- x<span style="color: #67b11d;">)</span> <span style="color: #67b11d;">(</span>1+ y<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 4: </span>Evaluating \(3 + 4\) with P&eacute;ano arithmetic</label><pre class="src src-scheme" id="org42db46c"><span style="color: #4f97d7;">(</span>peano+ 3 4<span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">(</span>peano+ <span style="color: #bc6ec5;">(</span>1- 3<span style="color: #bc6ec5;">)</span> <span style="color: #bc6ec5;">(</span>1+ 4<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">(</span>peano+ 2 5<span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">(</span>peano+ <span style="color: #bc6ec5;">(</span>1- 2<span style="color: #bc6ec5;">)</span> <span style="color: #bc6ec5;">(</span>1+ 5<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">(</span>peano+ 1 6<span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">(</span>peano+ <span style="color: #bc6ec5;">(</span>1- 1<span style="color: #bc6ec5;">)</span> <span style="color: #bc6ec5;">(</span>1+ 6<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">(</span>peano+ 0 7<span style="color: #4f97d7;">)</span>
7
</pre>
</div>

<p>
A similar, but very subtly different, implementation of addition is given in
listing&nbsp;<a href="#org113cf47">5</a>. 
As can be seen <code>peano+-2</code> is nearly identical to the former definition, however the process it evolves
in listing&nbsp;<a href="#orgd35d3df">6</a> is significantly different.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 5: </span>Alternative implemenation of addition in P&eacute;ano arithmetic</label><pre class="src src-scheme" id="org113cf47"><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">define</span> <span style="color: #bc6ec5;">(</span><span style="color: #bc6ec5; font-weight: bold;">peano+-2</span> x y<span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span><span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #2d9574;">(</span>= x 0<span style="color: #2d9574;">)</span>
      y
      <span style="color: #2d9574;">(</span>1+ <span style="color: #67b11d;">(</span>peano+-2 <span style="color: #b1951d;">(</span>1- x<span style="color: #b1951d;">)</span> y<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 6: </span>Evaluating \(3 + 4\) with alternative P&eacute;ano arithmetic implementaion</label><pre class="src src-scheme" id="orgd35d3df"><span style="color: #4f97d7;">(</span>peano+-2 3 4<span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">(</span>1+ <span style="color: #bc6ec5;">(</span>peano+-2 2 4<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">(</span>1+ <span style="color: #bc6ec5;">(</span>1+ <span style="color: #2d9574;">(</span>peano+-2 1 4<span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">(</span>1+ <span style="color: #bc6ec5;">(</span>1+ <span style="color: #2d9574;">(</span>1+ <span style="color: #67b11d;">(</span>peano+-2 0 4<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">(</span>1+ <span style="color: #bc6ec5;">(</span>1+ <span style="color: #2d9574;">(</span>1+ 4<span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">(</span>1+ <span style="color: #bc6ec5;">(</span>1+ 5<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">(</span>1+ 6<span style="color: #4f97d7;">)</span>
7
</pre>
</div>

<p>
Both approaches follow a common principle of reducing a problem to a simpler, base case for which
the answer is known, here \(x\rightarrow0\).
Each implementation also involves a number of steps proportional to the input <code>x</code> performing
\(\mathcal{O}\left(x\right)\) work.
The major difference is the work deferred by <code>peano+-2</code> building up a series of increments to be
performed once the base case is reached, the width of each line is in some sense the amount of stuff
the computer must remember, <code>peano+</code> is an <i>iteration</i> requiring constant memory
\(\mathcal{O}\left(1\right)\) whilst <code>peano+-2</code> has \(\mathcal{O}\left(x\right)\) memory requirements and
is thus a (linear) <i>recursion</i>.<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>
A key difference is that an iteration has <i>explicit state</i> stored in its variables - it can be stopped
and restarted as if nothing happened - whereas recursions store <i>implicit state</i> in the process.
</p>
</div>
</div>

<div id="outline-container-orgc65c272" class="outline-3">
<h3 id="orgc65c272"><span class="section-number-3">2.2</span> Designing procedures for recursive processes</h3>
<div class="outline-text-3" id="text-2-2">
<p>
The above examples are all recursively-defined algorithms, giving rise to either recursive or
iterative processes, in the case of recursive processes their designs all follow a similar pattern
</p>
<ol class="org-ol">
<li><i>Wishful thinking</i> - assume that a method exists for solving a smaller/simpler version of the
problem.</li>
<li><i>Decomposing the problem</i> - take the problem and split it into a combination of simple operations
and the solution to the smaller problem. This requires some ingenuity.</li>
<li><i>Identifying the &ldquo;smallest&rdquo; problem</i> - this problem is either non-decomposable or sufficiently
small that is solved directly.</li>
</ol>
<p>
This results in a program design that tests the input, applying either the <i>recursive case</i> or the
<i>base case</i> when the smallest input is reached.
</p>

<p>
Another well known recursive algorithm is calculating the factorial
</p>
\begin{equation}
  n! =
  \begin{cases}
    n \left( n - 1 \right)! & n > 1 \\
    1 & \mbox{otherwise}
  \end{cases}
\end{equation}
<p>
as can be seen it consists of a test resulting in either the application of a simple procedure
(multiplication) to a smaller version of the problem \(\left( n - 1 \right)!\), or a base case which
immediately returns its solution <i>i.e.</i> \(1\).
</p>

<p>
Defining a procedure for a recursive process follows relatively trivially following the mathematical
definition 
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">define</span> <span style="color: #bc6ec5;">(</span><span style="color: #bc6ec5; font-weight: bold;">fact</span> n<span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span><span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #2d9574;">(</span>&gt; n 1<span style="color: #2d9574;">)</span>
      <span style="color: #2d9574;">(</span>* n <span style="color: #67b11d;">(</span>fact <span style="color: #b1951d;">(</span>- n 1<span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span>
      1<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
</pre>
</div>
<p>
which as can be seen follows the above pattern: <i>assume</i> that there is a solution for the smaller
problem <code>(fact (- n 1))</code>; use this to solve the original problem with simple operations; test for the
base case where we can solve directly \(1! = 1\).
</p>
</div>
</div>

<div id="outline-container-org3702cd1" class="outline-3">
<h3 id="org3702cd1"><span class="section-number-3">2.3</span> Designing procedures for iterative processes</h3>
<div class="outline-text-3" id="text-2-3">
<p>
The design of iterative processes requires identifying how to accumulate partial results combined
with an initialisation step to start the process.
This can be visualised as creating a table where each row is determined from the previous row(s), <i>e.g.</i>
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Step</th>
<th scope="col" class="org-left">Result</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">\(0\)</td>
<td class="org-left">\(x_0\)</td>
</tr>

<tr>
<td class="org-left">\(1\)</td>
<td class="org-left">\(f\left( x_0 \right)\)</td>
</tr>

<tr>
<td class="org-left">&#x2026;</td>
<td class="org-left">&#x2026;</td>
</tr>
</tbody>
</table>

<p>
this is the explicit state referred to previously.
</p>

<p>
Applying this approach to the factorial it can be seen it is accumulating a series of products, <i>i.e.</i>
</p>
\begin{equation}
  \begin{split}
    n! &= n \times \left( n - 1 \right) \times \ldots \times 1 \\
    &= \left( n \times \left( n - 1 \right) \right) \times \ldots \times 1
  \end{split}
\end{equation}
<p>
by storing the running product, no deferred operations are necessary, yielding an iterative process!
An example implementation is given below:
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">define</span> <span style="color: #bc6ec5;">(</span><span style="color: #bc6ec5; font-weight: bold;">fact</span> n<span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span><span style="color: #4f97d7; font-weight: bold;">define</span> <span style="color: #2d9574;">(</span><span style="color: #bc6ec5; font-weight: bold;">fact-iter</span> product step<span style="color: #2d9574;">)</span>
    <span style="color: #2d9574;">(</span><span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #67b11d;">(</span>&gt; step n<span style="color: #67b11d;">)</span>
        product
        <span style="color: #67b11d;">(</span>fact-iter <span style="color: #b1951d;">(</span>* product step<span style="color: #b1951d;">)</span>
                   <span style="color: #b1951d;">(</span>+ step 1<span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span>fact-iter 1 1<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
</pre>
</div>

<p>
Note that compared to the recursive process which followed almost directly from the mathematical
definition, designing the procedure for an iterative process required additional consideration of
the problem.
</p>
</div>

<div id="outline-container-org028d744" class="outline-4">
<h4 id="org028d744"><span class="section-number-4">2.3.1</span> Exercise: An iterative Fibonacci process</h4>
<div class="outline-text-4" id="text-2-3-1">
<p>
A classic example of recursive procedures and processes are the Fibonacci numbers
</p>
\begin{equation*}
  Fib\left(n\right) =
  \begin{cases}
    0 & n = 0 \\
    1 & n = 1 \\
    Fib\left(n - 2\right) + Fib\left(n - 1\right) & \mbox{otherwise}
  \end{cases}
\end{equation*}
<p>
listing&nbsp;<a href="#org6ad73c6">7</a> translates this almost directly into <code>scheme</code>.
The process this evolves is <i>tree recursive</i> - as can be seen <code>(fib n)</code> requires evaluating <code>(fib (- n
1))</code> and <code>(fib (-n 2))</code>, <code>(fib (- n 1))</code> requires evaluating <code>(fib (- n 2))</code> and so on - resulting in an
exponential growth in work (in fact evaluating <code>(fib n)</code> requires
\(\mathcal{O}\left(Fib\left(n\right)\right)\) work) - the memory requirements can be determined by
examining the length of the longest branch, here memory is \(\mathcal{O}\left(n\right)\).
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 7: </span>Recursive implementation of \(Fib\left(n\right)\)</label><pre class="src src-scheme" id="org6ad73c6"><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">define</span> <span style="color: #bc6ec5;">(</span><span style="color: #bc6ec5; font-weight: bold;">fib</span> n<span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span><span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #2d9574;">(</span>&lt; n 2<span style="color: #2d9574;">)</span>
      n
      <span style="color: #2d9574;">(</span>+ <span style="color: #67b11d;">(</span>fib <span style="color: #b1951d;">(</span>- n 1<span style="color: #b1951d;">)</span>
              <span style="color: #b1951d;">(</span>- n 2<span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
</pre>
</div>

<p>
An iterative Fibonacci process would evaluate <code>(fib n)</code> in \(\mathcal{O}\left(1\right)\) space.
</p>

<p>
For the general case the new value can be computed from the two previous values, so an iterative
process requires storing these two pieces of information in addition to the counter to determine
when to stop, my implementation is given in listing&nbsp;<a href="#org81406c2">8</a>.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 8: </span>Iterative implementation of \(Fib\left(n\right)\)</label><pre class="src src-scheme" id="org81406c2"><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">define</span> <span style="color: #bc6ec5;">(</span><span style="color: #bc6ec5; font-weight: bold;">fib</span> n<span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span><span style="color: #4f97d7; font-weight: bold;">define</span> <span style="color: #2d9574;">(</span><span style="color: #bc6ec5; font-weight: bold;">fib-iter</span> ctr f1 f2<span style="color: #2d9574;">)</span>
    <span style="color: #2d9574;">(</span><span style="color: #4f97d7; font-weight: bold;">cond</span> <span style="color: #67b11d;">(</span><span style="color: #b1951d;">(</span>= ctr n<span style="color: #b1951d;">)</span>
           <span style="color: #b1951d;">(</span>+ f1 f2<span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span>
          <span style="color: #67b11d;">(</span><span style="color: #4f97d7; font-weight: bold;">else</span>
           <span style="color: #b1951d;">(</span>fib-iter <span style="color: #4f97d7;">(</span>1+ ctr<span style="color: #4f97d7;">)</span> <span style="color: #4f97d7;">(</span>+ f1 f2<span style="color: #4f97d7;">)</span> f1<span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span><span style="color: #4f97d7; font-weight: bold;">cond</span> <span style="color: #2d9574;">(</span><span style="color: #67b11d;">(</span>= n 0<span style="color: #67b11d;">)</span>
         0<span style="color: #2d9574;">)</span>
        <span style="color: #2d9574;">(</span><span style="color: #67b11d;">(</span>= n 1<span style="color: #67b11d;">)</span>
         1<span style="color: #2d9574;">)</span>
        <span style="color: #2d9574;">(</span><span style="color: #4f97d7; font-weight: bold;">else</span>
         <span style="color: #67b11d;">(</span>fib-iter 1 1 0<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
</pre>
</div>

<p>
The textbook implementation in listing&nbsp;<a href="#org69bc60e">9</a> is more elegant, handling the base
cases automatically.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 9: </span>Textbook iterative implementation of \(Fib\left(n\right)\)</label><pre class="src src-scheme" id="org69bc60e"><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">define</span> <span style="color: #bc6ec5;">(</span><span style="color: #bc6ec5; font-weight: bold;">fib</span> n<span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span><span style="color: #4f97d7; font-weight: bold;">define</span> <span style="color: #2d9574;">(</span><span style="color: #bc6ec5; font-weight: bold;">fib-iter</span> ctr f1 f2<span style="color: #2d9574;">)</span>
    <span style="color: #2d9574;">(</span><span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #67b11d;">(</span>= ctr 0<span style="color: #67b11d;">)</span>
        f2
        <span style="color: #67b11d;">(</span>fib-iter <span style="color: #b1951d;">(</span>1- ctr<span style="color: #b1951d;">)</span> <span style="color: #b1951d;">(</span>+ f1 f2<span style="color: #b1951d;">)</span> f1<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span>fib-iter n 1 0<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
</pre>
</div>

<p>
In addition to being \(\mathcal{O}\left(1\right)\) in space the iterative process is also
\(\mathcal{O}\left(n\right)\) in time, resulting in significant computational savings for \(n\rightarrow\infty\).
Whilst the tree-recursive process is computationally inefficient they are useful due to the ease of
implementation, the iterative process required effort up front to develop.<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup>
</p>
</div>
</div>
</div>

<div id="outline-container-org116f223" class="outline-3">
<h3 id="org116f223"><span class="section-number-3">2.4</span> Formal proofs</h3>
<div class="outline-text-3" id="text-2-4">
<p>
<i>This comes from the 3<sup>rd</sup> handout of the lecture notes.</i>
</p>

<p>
It is important to be able to have confidence in the results returned by a program - designing a
procedure that efficiently computes the wrong answer is not very useful!
One approach would be to simply test the program, however considering the range of possible inputs
would require <i>exhaustive</i> testing to show that the program won&rsquo;t fail for any (valid) input.
Alternatively, if a program can be <i>proven</i> correct it will work for all (valid) inputs.
</p>
</div>

<div id="outline-container-orgef9c8f2" class="outline-4">
<h4 id="orgef9c8f2"><span class="section-number-4">2.4.1</span> Proof by induction</h4>
<div class="outline-text-4" id="text-2-4-1">
<p>
To demonstrate this, consider the predicate
</p>
\begin{equation}
  P\left(n\right) : \sum^n_{l=0} 2^l = 2^{n+1} - 1
\end{equation}
<p>
to prove this is true for all possible inputs requires showing it holds for some base case, <i>e.g.</i>
\(n=0\):
</p>
\begin{equation}
  P\left( 0 \right) : 2^0 = 2^1 - 1 = 1 \Rightarrow P\left( 0 \right) = T
\end{equation}
<p>
Then it needs to be shown that the truth of the base case proves the truth of all other cases
</p>
\begin{equation}
  \begin{split}
    P\left(n+1\right) &: \sum^{n+1}_{l=0} 2^l &= \sum^n_{l=0} 2^l + 2^{n+1} \\
    & &= \left( 2^{n+1} - 1 \right) + 2^{n+1} \\
    & & = 2^{n+2} - 1 = 2^{\left(n + 1\right) + 1} - 1 \\
    \therefore \forall n>=0 &: P\left( n \right) &
  \end{split}
\end{equation}
<p>
because \(P\left(n\right)\) holds for the base case \(n=0\) and for the next case \(n+1\) it follows that
it holds for all \(n>=0\).
</p>
</div>
</div>

<div id="outline-container-org215847c" class="outline-4">
<h4 id="org215847c"><span class="section-number-4">2.4.2</span> Example: factorial</h4>
<div class="outline-text-4" id="text-2-4-2">
<p>
Returning to the factorial, the proof by induction can be demonstrated for a program.
</p>
\begin{equation}
  \begin{split}
    P(n)&:(define\ (fact\ n) \\
    &\qquad (if\ (=\ n\ 1) \\
    &\qquad\qquad 1 \\
    &\quad\qquad (*\ n\ (fact\ (-\ n\ 1)))))
  \end{split}
\end{equation}
<p>
For the base case \(n=1\) \((fact\ 1)\) returns \(1=1!\), therefore \(P\left(1\right)=T\).
To show it works for <i>all</i> positive integers:
</p>
\begin{equation}
  \begin{split}
    (fact\ (+\ n\ 1)) &= (*\ (+\ n\ 1)\ (fact\ n)) \\
    &= (*\ (+\ n\ 1)\ n!) = (n + 1)!
  \end{split}
\end{equation}
<p>
where it has been assumed that \((fact\ n) = n!\), as proven by the base case it can then be induced
that \(\forall{}n>0:P\left(n\right)\).
</p>

<p>
As this example shows, induction is a basis for understanding, analysing and proving the correctness
of recursive procedure definitions.
It can also be used in the design of programs - given a new problem:
</p>
<ol class="org-ol">
<li>Identify base case and solution</li>
<li>Turn to the issue of breaking the problem int a simpler version, assuming that the code will solve
the simpler version</li>
<li>Use that to construct the inductive step - <i>how</i> to solve the full problem</li>
</ol>
<p>
<i>c.f.</i> the procedures described in &sect;<a href="#orgc65c272">2.2</a> and &sect;<a href="#org3702cd1">2.3</a>. 
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgb52ac6f" class="outline-2">
<h2 id="orgb52ac6f"><span class="section-number-2">3</span> Orders of growth</h2>
<div class="outline-text-2" id="text-3">
<p>
Using a model, <i>e.g.</i> the substitution model, allows the evolution of a process from a procedure to be
determined and consequently an estimate of the required computational resources to execute it for a
given problem size \(R\left(n\right)\).
Such estimates are expressed in terms of order of growth
\(R\left(n\right)=\mathcal{O}\left(f\left(n\right)\right)\) where \(f\left(n\right)\) is the leading
order term in the growth trend <i>e.g.</i> the linear iterative process for P&eacute;ano addition is linear in
time \(\mathcal{O}\left(n\right)\) and constant in space \(\mathcal{O}\left(1\right)\).
Note these estimates are crude, ignoring the effect of coefficients and lower order terms, <i>e.g.</i>
\(f\left(n\right)=3n^2\) and \(f\left(n\right)=n^2+2n\) are both \(\mathcal{O}\left(n^{2}\right)\).
</p>
</div>

<div id="outline-container-orgc4bb523" class="outline-3">
<h3 id="orgc4bb523"><span class="section-number-3">3.1</span> Example: exponentiation</h3>
<div class="outline-text-3" id="text-3-1">
<p>
The examples already shown have demonstrated how different implementations can give rise to
processes with constant, linear or exponential orders of growth.
Exponentiation
</p>
\begin{equation}
  \begin{split}
    b^n &= b \times b^{n-1} \\
    b^0 &= 1
  \end{split}
\end{equation}
<p>
can be translated into a linear recursion
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">define</span> <span style="color: #bc6ec5;">(</span><span style="color: #bc6ec5; font-weight: bold;">expt</span> b n<span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span><span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #2d9574;">(</span>= n 0<span style="color: #2d9574;">)</span>
      1
      <span style="color: #2d9574;">(</span>* b <span style="color: #67b11d;">(</span>expt b <span style="color: #b1951d;">(</span>- n 1<span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
</pre>
</div>
<p>
a procedure for a linear iterative process can also be developed, similarly to the factorial
function.
</p>

<p>
A different kind of process can be developed by noting that exponents can be expressed as a series
of successive squares
</p>
\begin{equation}
  b^n =
  \begin{cases}
    {\left( b^{n/2} \right)}^2 & n\ \mbox{is even} \\
    b \times b^{n-1} & \mbox{otherwise}
  \end{cases}
\end{equation}
<p>
yielding the procedure
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">define</span> <span style="color: #bc6ec5;">(</span><span style="color: #bc6ec5; font-weight: bold;">fast-expt</span> b n<span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span><span style="color: #4f97d7; font-weight: bold;">cond</span> <span style="color: #2d9574;">(</span><span style="color: #67b11d;">(</span>= n 0<span style="color: #67b11d;">)</span>
         1<span style="color: #2d9574;">)</span>
        <span style="color: #2d9574;">(</span><span style="color: #67b11d;">(</span>even? n<span style="color: #67b11d;">)</span>
         <span style="color: #67b11d;">(</span>square <span style="color: #b1951d;">(</span>fast-expt b <span style="color: #4f97d7;">(</span>/ n 2<span style="color: #4f97d7;">)</span><span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span>
        <span style="color: #2d9574;">(</span><span style="color: #4f97d7; font-weight: bold;">else</span>
         <span style="color: #67b11d;">(</span>* b <span style="color: #b1951d;">(</span>fast-expt b <span style="color: #4f97d7;">(</span>- n 1<span style="color: #4f97d7;">)</span><span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
</pre>
</div>
<p>
This procedure evolves a recursive process (an iteration could also be written) however what is
interesting is the time complexity:
</p>
<ul class="org-ul">
<li>for even inputs the reduced problem size is halved</li>
<li>for odd inputs the reduced problem size is one smaller as before</li>
</ul>
<p>
this means that every two steps at most the problem size is approximately halved, consequently the
order of growth is logarithmic <i>i.e.</i> \(\mathcal{O}\left(log\left(n\right)\right)\).
Such processes are attractive as they are relatively insensitive to the size of the input.
</p>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
Note that both procedure definitions are recursive yet the processes they yield are an
iteration and a recursion, respectively.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
Could a <i>sufficiently smart</i> compiler transform an easy to specify tree-recursive procedure
into a more efficient one producing the same result?
</p></div></div>


</div>
</div>
