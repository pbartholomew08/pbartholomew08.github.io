---
layout: post
title: SICP Lecture 1A - Introduction
---

<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

<blockquote>
<p>
Computer science is a terrible name for this business - first of all it's not science, it might be
engineering or it might be art &#x2026;
It's also not really very much about computers. &#x2013; Hal Abelson
</p>
</blockquote>

<div id="outline-container-orgf03a10c" class="outline-2">
<h2 id="orgf03a10c"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
After several abortive attempts what better time to work through SICP than the <code>COVID-19</code> lockdown!
These are my notes based on the MIT-OCW lecture series videos in combination with the MIT-OCW
lecture notes from 2007 and the <i>Structure and Interpretation of Computer Programs 2<sup>nd</sup> ed.</i> book
itself.
This first video lecture covers roughly &sect;1.1.1-1.1.4 and &sect;1.1.6-1.1.7 of SICP, and is mostly
contained in lecture notes 1 and 2.
</p>

<p>
"Computer science" could be better understood as the <i>study of processes</i> that is "how to",
more formally <i>imperative</i>, knowledge.
This contrasts with "what is", or <i>declarative</i>, knowledge.
As an example, the statement
</p>
\begin{equation*}
  \begin{split}
    \sqrt{x}\ \mbox{is the } y\ \mbox{such that} \\
    y^2 = x,\ y \geq 0
  \end{split}
\end{equation*}
<p>
defines what the square root is, whereas Heron of Alexandria's algorithm
</p>
\begin{equation*}
  \begin{split}
    \mbox{Given an initial guess } y_0\\
    y_{n+1} = \frac{y_n + x/y_n}{2}\ \mbox{while } \left|y^2_n - x\right| > \varepsilon
  \end{split}
\end{equation*}
<p>
is a <i>procedure</i> for how to compute (or estimate) the square root.
<i>Evaluating</i> the procedure results in a <i>process</i> that evolves the input data to return a value.
</p>

<p>
Ultimately, we want to be able to perform complex tasks, this necessarily results in complex
processes, the aim of studying processes is <i>controlling complexity</i>.
SICP studies three approaches managing complexity:
</p>
<ol class="org-ol">
<li>Procedure and data abstraction
<ul class="org-ul">
<li>hiding complexity in "black boxes"</li>
</ul></li>
<li>Conventional interfaces and programming paradigms
<ul class="org-ul">
<li>standard ways of connecting simpler pieces
<ul class="org-ul">
<li>manifest typing</li>
<li>streams</li>
<li>object oriented programming</li>
</ul></li>
</ul></li>
<li>Metalinguistic abstraction
<ul class="org-ul">
<li>tayloring a language to fit the problem domain</li>
</ul></li>
</ol>

<p>
Around this point in the lecture Hal Abelson points out that the complexity stems only from the
problem itself: a physical implementation of a system using <i>real</i> components must also tackle
problems arising from physical constraints such as noise, tolerance, <i>etc</i>.; in contrast processes in
computer science are built from ideal <i>not</i> approximated components and thus are really only limited
by imagination.
</p>
</div>
</div>

<div id="outline-container-org78d4ca5" class="outline-2">
<h2 id="org78d4ca5"><span class="section-number-2">2</span> Black boxes</h2>
<div class="outline-text-2" id="text-2">
<p>
<a id="org4896cfc"></a>
</p>

<p>
The focus of this lecture is introducing black boxes as a means of abstraction.
</p>

<p>
Black boxes allow us to take the details of something, <i>e.g.</i> finding the square root of \(x\), and
abstract it away as a primitive object, <i>e.g.</i> a procedure <code>sqrt</code> which when supplied with \(x\) returns
\(y = \sqrt{x}\).
Knowing what <code>sqrt</code> does allows a user to use <code>sqrt</code> whenever a square root is needed without
necessarily knowing <i>how</i> to compute \(\sqrt{x}\), allowing them to concentrate on the task at hand and
combine it with other procedures to build yet more complex procedures.
</p>

<p>
A black box can also be used to express generality, for instance the method for finding a square
root described above is an example of finding the fixed point of a function
</p>
\begin{equation*}
  f \left( y \right) = y
\end{equation*}
<p>
so <code>sqrt</code> could be expressed as finding the fixed point of the function
</p>
\begin{equation*}
  f \left( y_{n+1} \right) = \frac{y_n + x / y_n}{2}
\end{equation*}
<p>
this would fundamentally be the same as Heron's algorithm, although the convergence test would be
looking for small changes in the result <i>i.e.</i> \(\Delta{}y\rightarrow0\).
</p>

<p>
In order to build these black boxes, a language must provide:
</p>
<ul class="org-ul">
<li>Primitive objects
<ul class="org-ul">
<li>what can we accept as true?</li>
</ul></li>
<li>Means of combination
<ul class="org-ul">
<li>how can we build compound elements from simpler ones?</li>
</ul></li>
<li>Means of abstraction
<ul class="org-ul">
<li>how can we express these compound elements as if they were primitive ones?</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org036766d" class="outline-2">
<h2 id="org036766d"><span class="section-number-2">3</span> A brief introduction to LISP</h2>
<div class="outline-text-2" id="text-3">
<p>
<a id="org2ad5e64"></a>
</p>

<p>
In SICP the scheme dialect of LISP is used (I will be using the guile implementation of scheme),
this brief introduction covers most of the basics of LISP/scheme.
</p>
</div>

<div id="outline-container-org8a59efb" class="outline-3">
<h3 id="org8a59efb"><span class="section-number-3">3.1</span> LISP primitives</h3>
<div class="outline-text-3" id="text-3-1">
<p>
<a id="org392f531"></a>
</p>

<p>
The simplest elements of LISP are the <i>self-evaluating</i> expressions, symbols which evaluate as
themselves, this includes <code>numbers</code>, <code>strings</code> and <code>Booleans</code>, <i>e.g.</i> <code>3</code>, <code>"hello world!"</code> and <code>#t</code> and <code>#f</code>.
These primitive objects can be manipulated using built-in procedures such as <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>,
<code>string-length</code>, <code>string=?</code>, <code>and</code> and <code>or</code>.
Interestingly while these operations are generally treated as <i>primitive</i>, they are in fact names or
<i>symbols</i> for procedures <i>e.g.</i> <code>+</code> is the name for the procedure <code>sum</code>.
</p>
</div>
</div>

<div id="outline-container-orgbf8184d" class="outline-3">
<h3 id="orgbf8184d"><span class="section-number-3">3.2</span> LISP combinations</h3>
<div class="outline-text-3" id="text-3-2">
<p>
<a id="orgc675979"></a>
</p>

<p>
LISP symbols are combined using parentheses to form a <i>combination</i> that is evaluated following
prefix-notation rules, <i>e.g.</i>
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #4f97d7;">(</span>+ 3 17.4 5<span style="color: #4f97d7;">)</span>
</pre>
</div>
<p>
is a combination comprising an <i>operator</i> whose value is a procedure followed by a list of operands.
<i>Evaluating</i> a combination returns a <i>value</i> by applying the operator procedure to the operand values
<i>i.e.</i> the operands are evaluated before evaluating the combination, allowing for <i>nested</i> combinations
<i>e.g.</i>
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #4f97d7;">(</span>+ <span style="color: #bc6ec5;">(</span>* 2 3<span style="color: #bc6ec5;">)</span>
   4<span style="color: #4f97d7;">)</span>
</pre>
</div>
<p>
is evaluated as
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #4f97d7;">(</span>+ 6 4<span style="color: #4f97d7;">)</span>
</pre>
</div>
<p>
returning <code>10</code> as its value.
</p>
</div>
</div>

<div id="outline-container-org68c989c" class="outline-3">
<h3 id="org68c989c"><span class="section-number-3">3.3</span> Abstracting in scheme</h3>
<div class="outline-text-3" id="text-3-3">
<p>
<a id="org0749374"></a>
</p>

<p>
It would not be very useful to have to write out procedures in full whenever they are required or
have mysterious numbers floating around, to resolve this abstraction is used to generate a <i>name</i>
whose <i>value</i> is the object, for instance
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">define</span> <span style="color: #bc6ec5; font-weight: bold;">pi</span> 3.14<span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">define</span> <span style="color: #bc6ec5; font-weight: bold;">a</span> <span style="color: #bc6ec5;">(</span>* 5 5<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
</pre>
</div>
<p>
creates two symbols <code>pi</code> and <code>a</code> whose values are <code>3.14</code> and the procedure <code>(* 5 5)</code>, respectively.
</p>

<p>
The above expressions are <i>special forms</i>, in that they don't follow the normal rules of evaluation.
Consider that if they did the interpreter would first have to evaluate <code>pi</code> before applying the <code>define</code>
procedure to the values of <code>pi</code> and <code>3.14</code> when the intention of the expression is to associate <code>3.14</code>
with the symbol <code>pi</code> in the current <i>environment</i> (here the <i>global</i> environment).
Following the definition, evaluating <code>pi</code> in this environment will return the value <code>3.14</code>.
</p>
</div>
</div>

<div id="outline-container-orgcd6dc8f" class="outline-3">
<h3 id="orgcd6dc8f"><span class="section-number-3">3.4</span> Evaluating combinations</h3>
<div class="outline-text-3" id="text-3-4">
<p>
<a id="org5b7bd24"></a>
</p>

<p>
As mentioned above in &sect;<a href="#orgc675979">3.2</a> a combination is evaluated in a two step procedure:
</p>
<ol class="org-ol">
<li>First, evaluate sub-expressions in the combination</li>
<li>Apply the procedure that is the value of the leftmost sub-expression (the operator) to the
arguments obtained as the values of the remaining sub-expressions (the operands).</li>
</ol>

<p>
As step 1 shows, the evaluation process is <i>recursive</i> in that it calls itself on the sub-expressions
of a combination.
This recursive definition allows evaluation of deeply nested combinations to be expressed very
clearly and succinctly.
A useful way to visualise how this evaluation process computes a value is by <i>tree accumulation</i>,
given a combination to evaluate
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #4f97d7;">(</span>* <span style="color: #bc6ec5;">(</span>+ 2 <span style="color: #2d9574;">(</span>* 4 6<span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span>
   <span style="color: #bc6ec5;">(</span>+ 3 5 7<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
</pre>
</div>
<p>
the process can be viewed as a tree where nodes represent evaluations and values are passed up the
branches.
Starting from the root node we evaluate it by passing in the operator and operands from its
branches, the nodes at the end of these branches are evaluated and so on until a terminal node with
a primitive procedure or value is reached, the values then percolate back up the tree to return a
value at the root node.
</p>
</div>
</div>

<div id="outline-container-orgd51269a" class="outline-3">
<h3 id="orgd51269a"><span class="section-number-3">3.5</span> Abstracting procedures</h3>
<div class="outline-text-3" id="text-3-5">
<p>
<a id="orgb4a93cc"></a>
</p>

<p>
As shown in &sect;<a href="#org0749374">3.3</a> the special form <code>define</code> links a value to a name which may be a
primitive expression as in the case of <code>pi</code> or a procedure as for <code>a</code>.
In the example <code>a</code>'s value is the procedure for squaring <code>5</code>, this is very specific and it is likely to
be more useful to create a general procedure, in scheme this is achieved by the <code>lambda</code> special form.
A procedure to compute the square of an arbitrary number could be created as follows
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">lambda</span> <span style="color: #bc6ec5;">(</span>x<span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span>* x x<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
</pre>
</div>
<p>
where the first operand is the list of <i>formal parameters</i> and the second is the <i>body</i> of procedure,
evaluating the <code>lambda</code> expression returns a procedure object which is some kind of machine
representation of a procedure.
</p>

<p>
Following the idea that <code>define</code> gives a value to a name we can combine these forms to create a named
procedure as follows
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">define</span> <span style="color: #bc6ec5; font-weight: bold;">square</span> <span style="color: #bc6ec5;">(</span><span style="color: #4f97d7; font-weight: bold;">lambda</span> <span style="color: #2d9574;">(</span>x<span style="color: #2d9574;">)</span>
                 <span style="color: #2d9574;">(</span>* x x<span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
</pre>
</div>
<p>
which will produce an object named <code>square</code> whose value is the procedure to square a number.
This is so useful and common an action that scheme provides the following <i>syntactic sugar</i> for naming
a procedure
</p>
<div class="org-src-container">
<pre class="src src-scheme" id="org3049bd5"><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">define</span> <span style="color: #bc6ec5;">(</span><span style="color: #bc6ec5; font-weight: bold;">square</span> x<span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span>* x x<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
</pre>
</div>
<p>
which is simply a shorthand for the previous definition.
Either way the resulting named procedure is called as <code>(square 4)</code> for example which should return <code>16</code>;
for the user <code>square</code> appears as a new primitive, indistinguishable from those built-in to the scheme
implementation which they could then use to build further procedures such as
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">define</span> <span style="color: #bc6ec5;">(</span><span style="color: #bc6ec5; font-weight: bold;">sum-of-squares</span> x y<span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span>+ <span style="color: #2d9574;">(</span>square x<span style="color: #2d9574;">)</span>
     <span style="color: #2d9574;">(</span>square y<span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
</pre>
</div>
<p>
This is better than simply writing out the full algebraic expression
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">define</span> <span style="color: #bc6ec5;">(</span><span style="color: #bc6ec5; font-weight: bold;">sum-of-squares</span> x y<span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span>+ <span style="color: #2d9574;">(</span>* x x<span style="color: #2d9574;">)</span>
     <span style="color: #2d9574;">(</span>* y y<span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
</pre>
</div>
<p>
as in the former we have captured the process of squaring a number in the <code>square</code> procedure,
introducing modularity allowing for reuse of <code>square</code> elsewhere and increasing readability by
suppressing detail through abstraction.
</p>

<p>
The basic steps of procedural abstraction are
</p>
<ol class="org-ol">
<li>Identify steps or "modules" in a process</li>
<li>Capture modules in a procedural abstraction</li>
<li>Create a procedure to control the interaction between modules</li>
</ol>
<p>
this idea can be applied recursively to each module, simplifying their implementation too.
</p>
</div>
</div>

<div id="outline-container-org09250e7" class="outline-3">
<h3 id="org09250e7"><span class="section-number-3">3.6</span> Conditional expressions and predicates</h3>
<div class="outline-text-3" id="text-3-6">
<p>
In general procedures must perform tests, for example the absolute value of \(x\) may be defined as
</p>
\begin{equation*}
  \left| x \right| =
  \begin{cases}
    x & x > 0 \\
    -x & x < 0 \\
    0 & \mbox{otherwise}
  \end{cases}
\end{equation*}
<p>
in LISP such a case analysis is implemented using the <code>cond</code> expression
</p>
<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">define</span> <span style="color: #bc6ec5;">(</span><span style="color: #bc6ec5; font-weight: bold;">abs</span> x<span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span><span style="color: #4f97d7; font-weight: bold;">cond</span> <span style="color: #2d9574;">(</span><span style="color: #67b11d;">(</span>&gt; x 0<span style="color: #67b11d;">)</span> x<span style="color: #2d9574;">)</span>
        <span style="color: #2d9574;">(</span><span style="color: #67b11d;">(</span>&lt; x 0<span style="color: #67b11d;">)</span> <span style="color: #67b11d;">(</span>- x<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span>
        <span style="color: #2d9574;">(</span><span style="color: #4f97d7; font-weight: bold;">else</span> 0<span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
</pre>
</div>
<p>
which follows from the mathematical definition.
</p>

<p>
The <code>cond</code> expression consists of a series of <i>clauses</i> made up of a predicate and a <i>consequent
expression</i>.
Each clause's predicate is evaluated in turn until one returns <i>true</i> when the <code>cond</code> expression returns
the value of the corresponding consequent expression, the <code>else</code> keyword handles the default case.
</p>

<p>
Whilst <code>cond</code> handles an arbitrary number of clauses, the <code>if</code> expression handles the <i>if-then-else</i> case
where the truth of a single predicate is tested returning either the <i>consequent</i> or the <i>alternate</i>
expression, an alternate definition of <code>abs</code> is given in listing&nbsp;<a href="#orgceb8af8">1</a>.
Either one may be implemented in terms of the other, generally a <code>sceme</code> implementation would pick one
and then implement the other.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>Implementation of <code>abs</code> using <code>if</code></label><pre class="src src-scheme" id="orgceb8af8"><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">define</span> <span style="color: #bc6ec5;">(</span><span style="color: #bc6ec5; font-weight: bold;">abs</span> x<span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span><span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #2d9574;">(</span>&lt; x 0<span style="color: #2d9574;">)</span>
      <span style="color: #2d9574;">(</span>- x<span style="color: #2d9574;">)</span>
      x<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgbd6260f" class="outline-2">
<h2 id="orgbd6260f"><span class="section-number-2">4</span> Example: Computing square roots</h2>
<div class="outline-text-2" id="text-4">
<p>
As pointed out in &sect;<a href="#org4896cfc">2</a> Heron of Alexandria's algorithm for computing square roots can be
expressed as finding the fixed point of a function, it is in fact an application of Newton's method
</p>
\begin{equation*}
  \begin{split}
    f \left( y_{n+1} \right) &= f \left( y_n \right) + \left. \Delta y \frac{\partial f}{\partial y}
    \right|_n = 0 \\
    \Rightarrow y_{n+1} &= y_n - \left. \frac{\partial f}{\partial y} \right|^{-1}_n f \left( y_n
    \right)
  \end{split}
\end{equation*}
<p>
to the function \(f\left( y \right) = y^2 - x\).
</p>

<p>
Applying the process of procedural abstraction outlined above, Newton's method has three major
components:
</p>
<ol class="org-ol">
<li>testing whether a guess is good enough</li>
<li>if not yet good enough, compute an improved guess and</li>
<li>organise testing and updating the guess.</li>
</ol>

<p>
A simple test of whether the guess is good enough is to square it and compare with <code>x</code>, this is
implemented in listing&nbsp;<a href="#orge782446">2</a>.
An improved guess is computed by subtracting the inverse gradient times the current function
evaluation from the current guess, implemented in listing&nbsp;<a href="#org83e4fe0">3</a>.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 2: </span>Testing whether the guess sufficiently approximates \(\sqrt{x}\)</label><pre class="src src-scheme" id="orge782446"><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">define</span> <span style="color: #bc6ec5;">(</span><span style="color: #bc6ec5; font-weight: bold;">good-enough?</span> guess x<span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span>&lt; <span style="color: #2d9574;">(</span>abs <span style="color: #67b11d;">(</span>func guess x<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span>
     0.001<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 3: </span>Computing an improved guess to \(\sqrt{x}\) given the current guess</label><pre class="src src-scheme" id="org83e4fe0"><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">define</span> <span style="color: #bc6ec5;">(</span><span style="color: #bc6ec5; font-weight: bold;">grad</span> guess<span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span>* 2 guess<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">define</span> <span style="color: #bc6ec5;">(</span><span style="color: #bc6ec5; font-weight: bold;">improve-guess</span> guess x<span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span>- guess <span style="color: #2d9574;">(</span>/ <span style="color: #67b11d;">(</span>func guess x<span style="color: #67b11d;">)</span>
              <span style="color: #67b11d;">(</span>grad guess<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
</pre>
</div>

<p>
The process of repeatedly testing and if necessary improving the guess is implemented by the
<code>sqrt-iter</code> procedure which uses the <code>if</code> special form to determine which action to take based on the
current guess, recursively calling itself with an improved guess if not sufficiently close to the
solution.
Finally the <code>sqrt</code> function pulls this all together, using <code>1.0</code> as an initial guess<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>.
Note that in the above the function evaluation has been abstracted as the <code>func</code> procedure also
defined here.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 4: </span>Defining the <code>sqrt</code> procedure</label><pre class="src src-scheme" id="org29f2c46">
<span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">define</span> <span style="color: #bc6ec5;">(</span><span style="color: #bc6ec5; font-weight: bold;">func</span> guess x<span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span>- <span style="color: #2d9574;">(</span>square guess<span style="color: #2d9574;">)</span> x<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>


<span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">define</span> <span style="color: #bc6ec5;">(</span><span style="color: #bc6ec5; font-weight: bold;">sqrt-iter</span> guess x<span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span><span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #2d9574;">(</span>good-enough? guess x<span style="color: #2d9574;">)</span>
      guess
      <span style="color: #2d9574;">(</span>sqrt-iter <span style="color: #67b11d;">(</span>improve-guess guess x<span style="color: #67b11d;">)</span> x<span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>

<span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">define</span> <span style="color: #bc6ec5;">(</span><span style="color: #bc6ec5; font-weight: bold;">sqrt</span> x<span style="color: #bc6ec5;">)</span>
  <span style="color: #bc6ec5;">(</span>sqrt-iter 1.0 x<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
</pre>
</div>

<p>
Applying <code>sqrt</code> to some numbers whose square root is known yields
</p>
<div class="org-src-container">
<pre class="src src-scheme">
<span style="color: #4f97d7;">(</span>sqrt 4<span style="color: #4f97d7;">)</span>
</pre>
</div>

<pre class="example">
2.0000000929222947

</pre>

<p>
and
</p>
<div class="org-src-container">
<pre class="src src-scheme">
<span style="color: #4f97d7;">(</span>sqrt 2<span style="color: #4f97d7;">)</span>
</pre>
</div>

<pre class="example">
1.4142156862745099

</pre>

<p>
which should be close to expected values (note that <code>good-enough?</code> is relatively crude).
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
It can be shown that using <code>1.0</code> as an initial guess will converge to the solution.
</p></div></div>


</div>
</div>
